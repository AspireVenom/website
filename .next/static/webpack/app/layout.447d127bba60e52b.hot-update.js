"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./components/InitClient.tsx":
/*!***********************************!*\
  !*** ./components/InitClient.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ InitClient; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var aos__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aos */ \"(app-pages-browser)/./node_modules/aos/dist/aos.js\");\n/* harmony import */ var aos__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(aos__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\n\n\nfunction isHTMLElement(el) {\n    return !!el && el instanceof HTMLElement;\n}\nfunction InitClient() {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Initialize AOS\n        aos__WEBPACK_IMPORTED_MODULE_1___default().init({\n            duration: 1000,\n            easing: \"ease-out-cubic\",\n            offset: 100,\n            once: true\n        });\n        // Typing intro and mobile variant\n        const intro = document.querySelector(\".intro\");\n        const cursor = document.getElementById(\"cursor\");\n        const isMobile = window.innerWidth <= 768;\n        function moveCursorTo(el) {\n            if (!isHTMLElement(cursor) || !isHTMLElement(intro)) return;\n            const rect = el.getBoundingClientRect();\n            const introRect = intro.getBoundingClientRect();\n            cursor.style.top = \"\".concat(rect.top - introRect.top, \"px\");\n            cursor.style.left = \"\".concat(rect.left - introRect.left + rect.width + 2, \"px\");\n        }\n        const timeouts = [];\n        if (!isMobile) {\n            const line1 = document.getElementById(\"line1\");\n            const line2 = document.getElementById(\"line2\");\n            const line1Text = \"Douglas Alvarino\";\n            const line2Text = \"Engineer || Developer || Explorer\";\n            let i = 0;\n            let j = 0;\n            // Reset any pre-existing content to avoid doubled characters on HMR/remount\n            if (line1) line1.textContent = \"\";\n            if (line2) line2.textContent = \"\";\n            function typeLine1() {\n                if (!line1) return;\n                if (i < line1Text.length) {\n                    line1.textContent = (line1.textContent || \"\") + line1Text.charAt(i);\n                    moveCursorTo(line1);\n                    i++;\n                    timeouts.push(window.setTimeout(typeLine1, 80));\n                } else {\n                    timeouts.push(window.setTimeout(typeLine2, 400));\n                }\n            }\n            function typeLine2() {\n                if (!line2) return;\n                if (j < line2Text.length) {\n                    line2.textContent = (line2.textContent || \"\") + line2Text.charAt(j);\n                    moveCursorTo(line2);\n                    j++;\n                    timeouts.push(window.setTimeout(typeLine2, 80));\n                }\n            }\n            timeouts.push(window.setTimeout(typeLine1, 350));\n        } else {\n            if (isHTMLElement(intro) && isHTMLElement(cursor)) {\n                var _document_getElementById, _document_getElementById1;\n                (_document_getElementById = document.getElementById(\"line1-container\")) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.remove();\n                (_document_getElementById1 = document.getElementById(\"line2-container\")) === null || _document_getElementById1 === void 0 ? void 0 : _document_getElementById1.remove();\n                const mobileLines = [\n                    \"Douglas Alvarino\",\n                    \"Engineer || Developer || Explorer\"\n                ];\n                let currentLine = 0;\n                let charIndex = 0;\n                const lineSpans = [];\n                const promptSpans = [];\n                for(let i = 0; i < mobileLines.length; i++){\n                    const lineDiv = document.createElement(\"div\");\n                    lineDiv.className = \"terminal-line\";\n                    const promptSpan = document.createElement(\"span\");\n                    promptSpan.className = \"prompt\";\n                    promptSpan.textContent = \"\";\n                    promptSpans.push(promptSpan);\n                    const span = document.createElement(\"span\");\n                    span.id = \"mobile-line-\".concat(i);\n                    lineSpans.push(span);\n                    lineDiv.appendChild(promptSpan);\n                    lineDiv.appendChild(span);\n                    intro.insertBefore(lineDiv, cursor);\n                }\n                function typeMobileLine() {\n                    if (currentLine >= mobileLines.length) return;\n                    const prompt = promptSpans[currentLine];\n                    const span = lineSpans[currentLine];\n                    const text = mobileLines[currentLine];\n                    function typePrompt() {\n                        prompt.textContent = \"> \";\n                        moveCursorTo(prompt);\n                        timeouts.push(window.setTimeout(typeWord, 180));\n                    }\n                    function typeWord() {\n                        if (charIndex < text.length) {\n                            span.textContent = (span.textContent || \"\") + text.charAt(charIndex);\n                            moveCursorTo(span);\n                            charIndex++;\n                            timeouts.push(window.setTimeout(typeWord, 80));\n                        } else {\n                            currentLine++;\n                            charIndex = 0;\n                            timeouts.push(window.setTimeout(typeMobileLine, 300));\n                        }\n                    }\n                    typePrompt();\n                }\n                timeouts.push(window.setTimeout(typeMobileLine, 350));\n            }\n        }\n        // Scroll cue\n        const cue = document.getElementById(\"scroll-cue\");\n        const aboutSection = document.getElementById(\"about\");\n        let scrolled = false;\n        function scrollToAbout() {\n            if (!scrolled && isHTMLElement(aboutSection)) {\n                scrolled = true;\n                aboutSection.scrollIntoView({\n                    behavior: \"smooth\"\n                });\n            }\n        }\n        cue === null || cue === void 0 ? void 0 : cue.addEventListener(\"click\", scrollToAbout);\n        const onWheel = (e)=>{\n            if (e.deltaY > 0) scrollToAbout();\n        };\n        window.addEventListener(\"wheel\", onWheel, {\n            passive: true\n        });\n        // Navbar hamburger toggle\n        const hamburger = document.getElementById(\"hamburger\");\n        const navLinks = document.getElementById(\"nav-links\");\n        const onHamburger = ()=>{\n            hamburger === null || hamburger === void 0 ? void 0 : hamburger.classList.toggle(\"active\");\n            navLinks === null || navLinks === void 0 ? void 0 : navLinks.classList.toggle(\"show\");\n        };\n        hamburger === null || hamburger === void 0 ? void 0 : hamburger.addEventListener(\"click\", onHamburger);\n        navLinks === null || navLinks === void 0 ? void 0 : navLinks.querySelectorAll(\"a\").forEach((link)=>{\n            link.addEventListener(\"click\", ()=>{\n                if (window.innerWidth <= 768) {\n                    navLinks.classList.remove(\"show\");\n                    hamburger === null || hamburger === void 0 ? void 0 : hamburger.classList.remove(\"active\");\n                }\n            });\n        });\n        // Skills carousel and filters\n        const skillsCarousel = document.getElementById(\"skills-carousel\");\n        const skillsCategories = document.getElementById(\"skills-categories\");\n        const carouselWrapper = document.querySelector(\".carousel-skill-card-wrapper\");\n        const leftArrow = document.getElementById(\"carousel-left\");\n        const rightArrow = document.getElementById(\"carousel-right\");\n        const filterBar = document.getElementById(\"skills-filter\");\n        const filterButtons = Array.from(document.querySelectorAll(\".filter-btn\"));\n        let allSkillCards = Array.from(document.querySelectorAll(\".skill-card\")).map((card)=>card.cloneNode(true));\n        let carouselIndex = 0;\n        function showCarouselSkill(idx) {\n            if (!carouselWrapper) return;\n            carouselWrapper.innerHTML = \"\";\n            const card = allSkillCards[idx];\n            if (card) {\n                carouselWrapper.appendChild(card);\n                const progressBar = card.querySelector(\".progress-bar\");\n                if (progressBar) {\n                    const progress = card.dataset.level || \"0\";\n                    progressBar.style.setProperty(\"--progress-width\", \"\".concat(progress, \"%\"));\n                    card.classList.add(\"animate\");\n                    setTimeout(()=>{\n                        progressBar.style.width = \"\".concat(progress, \"%\");\n                    }, 100);\n                }\n            }\n            leftArrow === null || leftArrow === void 0 ? void 0 : leftArrow.toggleAttribute(\"disabled\", idx === 0);\n            rightArrow === null || rightArrow === void 0 ? void 0 : rightArrow.toggleAttribute(\"disabled\", idx === allSkillCards.length - 1);\n        }\n        function activateCarousel() {\n            allSkillCards = Array.from(document.querySelectorAll(\".skill-card\")).map((card)=>card.cloneNode(true));\n            if (skillsCarousel) skillsCarousel.style.display = \"\";\n            skillsCategories === null || skillsCategories === void 0 ? void 0 : skillsCategories.classList.add(\"hide\");\n            carouselIndex = 0;\n            showCarouselSkill(carouselIndex);\n        }\n        function deactivateCarousel() {\n            if (skillsCarousel) skillsCarousel.style.display = \"none\";\n            skillsCategories === null || skillsCategories === void 0 ? void 0 : skillsCategories.classList.remove(\"hide\");\n        }\n        leftArrow === null || leftArrow === void 0 ? void 0 : leftArrow.addEventListener(\"click\", ()=>{\n            if (carouselIndex > 0) {\n                carouselIndex--;\n                showCarouselSkill(carouselIndex);\n            }\n        });\n        rightArrow === null || rightArrow === void 0 ? void 0 : rightArrow.addEventListener(\"click\", ()=>{\n            if (carouselIndex < allSkillCards.length - 1) {\n                carouselIndex++;\n                showCarouselSkill(carouselIndex);\n            }\n        });\n        let skillsStartX = 0;\n        let skillsSwiping = false;\n        carouselWrapper === null || carouselWrapper === void 0 ? void 0 : carouselWrapper.addEventListener(\"touchstart\", (e)=>{\n            skillsStartX = e.touches[0].clientX;\n            skillsSwiping = true;\n        });\n        carouselWrapper === null || carouselWrapper === void 0 ? void 0 : carouselWrapper.addEventListener(\"touchmove\", (e)=>{\n            if (!skillsSwiping) return;\n            const diffX = e.touches[0].clientX - skillsStartX;\n            if (Math.abs(diffX) > 50) {\n                if (diffX < 0 && carouselIndex < allSkillCards.length - 1) {\n                    carouselIndex++;\n                    showCarouselSkill(carouselIndex);\n                } else if (diffX > 0 && carouselIndex > 0) {\n                    carouselIndex--;\n                    showCarouselSkill(carouselIndex);\n                }\n                skillsSwiping = false;\n            }\n        });\n        carouselWrapper === null || carouselWrapper === void 0 ? void 0 : carouselWrapper.addEventListener(\"touchend\", ()=>{\n            skillsSwiping = false;\n        });\n        filterBar === null || filterBar === void 0 ? void 0 : filterBar.addEventListener(\"click\", (e)=>{\n            const target = e.target;\n            if (!target.classList.contains(\"filter-btn\")) return;\n            filterButtons.forEach((btn)=>btn.classList.remove(\"active\"));\n            target.classList.add(\"active\");\n            const filter = target.dataset.filter;\n            if (filter === \"all\") {\n                activateCarousel();\n            } else {\n                deactivateCarousel();\n                document.querySelectorAll(\".skill-category\").forEach((cat)=>{\n                    cat.style.display = cat.dataset.category === filter ? \"\" : \"none\";\n                });\n                document.querySelectorAll(\".skill-category\").forEach((cat)=>{\n                    if (cat.style.display !== \"none\") {\n                        cat.querySelectorAll(\".skill-card\").forEach((card)=>{\n                            const progressBar = card.querySelector(\".progress-bar\");\n                            const progress = card.dataset.level || \"0\";\n                            if (progressBar) {\n                                progressBar.style.width = \"0%\";\n                                progressBar.style.setProperty(\"--progress-width\", \"\".concat(progress, \"%\"));\n                                card.classList.remove(\"animate\");\n                                void progressBar.offsetWidth;\n                                card.classList.add(\"animate\");\n                                setTimeout(()=>{\n                                    progressBar.style.width = \"\".concat(progress, \"%\");\n                                }, 100);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n        const programmingBtn = filterButtons.find((btn)=>btn.dataset.filter === \"programming\");\n        if (programmingBtn) setTimeout(()=>programmingBtn.click(), 0);\n        // Highlight projects carousel\n        const track = document.querySelector(\".carousel-track\");\n        const nodes = Array.from(document.querySelectorAll(\".highlight-node\"));\n        const prevBtn = document.getElementById(\"carousel-prev\");\n        const nextBtn = document.getElementById(\"carousel-next\");\n        let currentIndex = 0;\n        let slideWidth = 0;\n        let gapPx = 0;\n        function measureSlides() {\n            if (!track || nodes.length === 0) return;\n            slideWidth = nodes[0].getBoundingClientRect().width;\n            const styles = window.getComputedStyle(track);\n            // gap may be like \"16px\"\n            const parsed = parseFloat(styles.gap || \"0\");\n            gapPx = Number.isNaN(parsed) ? 0 : parsed;\n        }\n        function applySlideClasses() {\n            nodes.forEach((node, idx)=>{\n                const isActive = idx === currentIndex;\n                const isNear = idx === currentIndex - 1 || idx === currentIndex + 1;\n                const isFar = Math.abs(idx - currentIndex) > 1;\n                node.classList.toggle(\"slide--active\", isActive);\n                node.classList.toggle(\"slide--near\", isNear);\n                node.classList.toggle(\"slide--far\", isFar);\n            });\n        }\n        function updateCarousel() {\n            if (!track) return;\n            const offsetPx = -(slideWidth + gapPx) * currentIndex;\n            track.style.transform = \"translateX(\".concat(offsetPx, \"px)\");\n            applySlideClasses();\n        }\n        prevBtn === null || prevBtn === void 0 ? void 0 : prevBtn.addEventListener(\"click\", ()=>{\n            if (currentIndex > 0) {\n                currentIndex--;\n                updateCarousel();\n            }\n        });\n        nextBtn === null || nextBtn === void 0 ? void 0 : nextBtn.addEventListener(\"click\", ()=>{\n            if (currentIndex < nodes.length - 1) {\n                currentIndex++;\n                updateCarousel();\n            }\n        });\n        let projectStartX = 0;\n        let projectSwiping = false;\n        track === null || track === void 0 ? void 0 : track.addEventListener(\"touchstart\", (e)=>{\n            projectStartX = e.touches[0].clientX;\n            projectSwiping = true;\n        });\n        track === null || track === void 0 ? void 0 : track.addEventListener(\"touchmove\", (e)=>{\n            if (!projectSwiping) return;\n            const diffX = e.touches[0].clientX - projectStartX;\n            if (Math.abs(diffX) > 50) {\n                if (diffX < 0 && currentIndex < nodes.length - 1) currentIndex++;\n                else if (diffX > 0 && currentIndex > 0) currentIndex--;\n                updateCarousel();\n                projectSwiping = false;\n            }\n        });\n        track === null || track === void 0 ? void 0 : track.addEventListener(\"touchend\", ()=>{\n            projectSwiping = false;\n        });\n        activateCarousel();\n        measureSlides();\n        updateCarousel();\n        const onResizeCarousel = ()=>{\n            measureSlides();\n            updateCarousel();\n        };\n        window.addEventListener(\"resize\", onResizeCarousel);\n        // Navbar hide/show on scroll\n        let lastScrollTop = 0;\n        const navbar = document.querySelector(\".navbar\");\n        const onScroll = ()=>{\n            const scrollTop = window.scrollY || document.documentElement.scrollTop;\n            if (scrollTop > lastScrollTop) navbar === null || navbar === void 0 ? void 0 : navbar.classList.add(\"navbar-hidden\");\n            else navbar === null || navbar === void 0 ? void 0 : navbar.classList.remove(\"navbar-hidden\");\n            lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;\n        };\n        window.addEventListener(\"scroll\", onScroll, {\n            passive: true\n        });\n        // Matrix background canvas under #landing\n        const landingEl = document.getElementById(\"landing\");\n        if (landingEl) {\n            const matrixCanvas = document.createElement(\"canvas\");\n            const landing = landingEl; // narrow for inner closures\n            landing.style.position = \"relative\";\n            landing.appendChild(matrixCanvas);\n            const ctx = matrixCanvas.getContext(\"2d\");\n            if (!ctx) {\n                // Cleanup fallback\n                return ()=>{\n                    window.removeEventListener(\"wheel\", onWheel);\n                    window.removeEventListener(\"scroll\", onScroll);\n                    hamburger === null || hamburger === void 0 ? void 0 : hamburger.removeEventListener(\"click\", onHamburger);\n                };\n            }\n            const context = ctx;\n            // Style assignments\n            matrixCanvas.style.position = \"absolute\";\n            matrixCanvas.style.top = \"0\";\n            matrixCanvas.style.left = \"0\";\n            matrixCanvas.style.width = \"100%\";\n            matrixCanvas.style.height = \"100%\";\n            matrixCanvas.style.zIndex = \"0\";\n            matrixCanvas.style.pointerEvents = \"none\";\n            matrixCanvas.style.opacity = \"0.08\";\n            matrixCanvas.style.transition = \"opacity 0.3s ease\";\n            const letters = \"01アカサタナハマヤラ0123456789\";\n            const fontSize = 14;\n            let drops = [];\n            let lastWidth = 0;\n            let lastHeight = 0;\n            function resizeMatrixCanvas() {\n                let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n                const width = landing.clientWidth;\n                const height = window.innerHeight;\n                if (!force && width === lastWidth && height === lastHeight) return;\n                const oldColumns = drops.length;\n                const newColumns = Math.floor(width / fontSize);\n                if (matrixCanvas.width !== width) matrixCanvas.width = width;\n                if (matrixCanvas.height !== height) matrixCanvas.height = height;\n                if (newColumns !== oldColumns) {\n                    const oldDrops = [\n                        ...drops\n                    ];\n                    drops.length = newColumns;\n                    for(let i = 0; i < newColumns; i++){\n                        drops[i] = oldDrops[i] || 1;\n                    }\n                }\n                context.font = \"14px 'Courier New', monospace\";\n                lastWidth = width;\n                lastHeight = height;\n            }\n            function drawMatrix() {\n                context.fillStyle = \"rgba(0, 0, 0, 0.05)\";\n                context.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);\n                context.fillStyle = \"#0f0\";\n                for(let i = 0; i < drops.length; i++){\n                    const text = letters.charAt(Math.floor(Math.random() * letters.length));\n                    context.fillText(text, i * fontSize, drops[i] * fontSize);\n                    if (drops[i] * fontSize > matrixCanvas.height || Math.random() > 0.975) {\n                        drops[i] = 0;\n                    }\n                    drops[i]++;\n                }\n            }\n            resizeMatrixCanvas(true);\n            const interval = window.setInterval(drawMatrix, 50);\n            let resizeTimeout;\n            const onResize = ()=>{\n                window.clearTimeout(resizeTimeout);\n                resizeTimeout = window.setTimeout(()=>resizeMatrixCanvas(), 200);\n            };\n            window.addEventListener(\"resize\", onResize);\n            // Cleanup canvas listeners/interval\n            return ()=>{\n                timeouts.forEach((id)=>window.clearTimeout(id));\n                window.removeEventListener(\"resize\", onResize);\n                window.removeEventListener(\"resize\", onResizeCarousel);\n                window.removeEventListener(\"wheel\", onWheel);\n                window.removeEventListener(\"scroll\", onScroll);\n                hamburger === null || hamburger === void 0 ? void 0 : hamburger.removeEventListener(\"click\", onHamburger);\n                window.clearInterval(interval);\n            };\n        }\n        // Cleanup for non-canvas case\n        return ()=>{\n            timeouts.forEach((id)=>window.clearTimeout(id));\n            window.removeEventListener(\"wheel\", onWheel);\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onResizeCarousel);\n            hamburger === null || hamburger === void 0 ? void 0 : hamburger.removeEventListener(\"click\", onHamburger);\n        };\n    }, []);\n    return null;\n}\n_s(InitClient, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = InitClient;\nvar _c;\n$RefreshReg$(_c, \"InitClient\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvSW5pdENsaWVudC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRWtDO0FBQ1o7QUFFdEIsU0FBU0UsY0FBbURDLEVBQWtCO0lBQzVFLE9BQU8sQ0FBQyxDQUFDQSxNQUFNQSxjQUFjQztBQUMvQjtBQUVlLFNBQVNDOztJQUN0QkwsZ0RBQVNBLENBQUM7UUFDUixpQkFBaUI7UUFDakJDLCtDQUFRLENBQUM7WUFBRU0sVUFBVTtZQUFNQyxRQUFRO1lBQWtCQyxRQUFRO1lBQUtDLE1BQU07UUFBSztRQUU3RSxrQ0FBa0M7UUFDbEMsTUFBTUMsUUFBUUMsU0FBU0MsYUFBYSxDQUFDO1FBQ3JDLE1BQU1DLFNBQVNGLFNBQVNHLGNBQWMsQ0FBQztRQUV2QyxNQUFNQyxXQUFXQyxPQUFPQyxVQUFVLElBQUk7UUFFdEMsU0FBU0MsYUFBYWhCLEVBQVc7WUFDL0IsSUFBSSxDQUFDRCxjQUFjWSxXQUFXLENBQUNaLGNBQWNTLFFBQVE7WUFDckQsTUFBTVMsT0FBTyxHQUFvQkMscUJBQXFCO1lBQ3RELE1BQU1DLFlBQVlYLE1BQU1VLHFCQUFxQjtZQUM3Q1AsT0FBT1MsS0FBSyxDQUFDQyxHQUFHLEdBQUcsR0FBNEIsT0FBekJKLEtBQUtJLEdBQUcsR0FBR0YsVUFBVUUsR0FBRyxFQUFDO1lBQy9DVixPQUFPUyxLQUFLLENBQUNFLElBQUksR0FBRyxHQUErQyxPQUE1Q0wsS0FBS0ssSUFBSSxHQUFHSCxVQUFVRyxJQUFJLEdBQUdMLEtBQUtNLEtBQUssR0FBRyxHQUFFO1FBQ3JFO1FBRUEsTUFBTUMsV0FBcUIsRUFBRTtRQUU3QixJQUFJLENBQUNYLFVBQVU7WUFDYixNQUFNWSxRQUFRaEIsU0FBU0csY0FBYyxDQUFDO1lBQ3RDLE1BQU1jLFFBQVFqQixTQUFTRyxjQUFjLENBQUM7WUFDdEMsTUFBTWUsWUFBWTtZQUNsQixNQUFNQyxZQUFZO1lBQ2xCLElBQUlDLElBQUk7WUFDUixJQUFJQyxJQUFJO1lBQ1IsNEVB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LG1CQUFtQixDQUFDLFNBQVM5RjtZQUNwQ2xELE9BQU9nSixtQkFBbUIsQ0FBQyxVQUFVVjtZQUNyQ3RJLE9BQU9nSixtQkFBbUIsQ0FBQyxVQUFVYjtZQUNyQzdFLHNCQUFBQSxnQ0FBQUEsVUFBVzBGLG1CQUFtQixDQUFDLFNBQVN4RjtRQUMxQztJQUNGLEdBQUcsRUFBRTtJQUVMLE9BQU87QUFDVDtHQS9Yd0JwRTtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0luaXRDbGllbnQudHN4P2Y4ODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQU9TIGZyb20gJ2Fvcyc7XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQ8VCBleHRlbmRzIEhUTUxFbGVtZW50ID0gSFRNTEVsZW1lbnQ+KGVsOiBFbGVtZW50IHwgbnVsbCk6IGVsIGlzIFQge1xuICByZXR1cm4gISFlbCAmJiBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbml0Q2xpZW50KCkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEluaXRpYWxpemUgQU9TXG4gICAgQU9TLmluaXQoeyBkdXJhdGlvbjogMTAwMCwgZWFzaW5nOiAnZWFzZS1vdXQtY3ViaWMnLCBvZmZzZXQ6IDEwMCwgb25jZTogdHJ1ZSB9KTtcblxuICAgIC8vIFR5cGluZyBpbnRybyBhbmQgbW9iaWxlIHZhcmlhbnRcbiAgICBjb25zdCBpbnRybyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRybycpO1xuICAgIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJzb3InKTtcblxuICAgIGNvbnN0IGlzTW9iaWxlID0gd2luZG93LmlubmVyV2lkdGggPD0gNzY4O1xuXG4gICAgZnVuY3Rpb24gbW92ZUN1cnNvclRvKGVsOiBFbGVtZW50KSB7XG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoY3Vyc29yKSB8fCAhaXNIVE1MRWxlbWVudChpbnRybykpIHJldHVybjtcbiAgICAgIGNvbnN0IHJlY3QgPSAoZWwgYXMgSFRNTEVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgaW50cm9SZWN0ID0gaW50cm8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjdXJzb3Iuc3R5bGUudG9wID0gYCR7cmVjdC50b3AgLSBpbnRyb1JlY3QudG9wfXB4YDtcbiAgICAgIGN1cnNvci5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0IC0gaW50cm9SZWN0LmxlZnQgKyByZWN0LndpZHRoICsgMn1weGA7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZW91dHM6IG51bWJlcltdID0gW107XG5cbiAgICBpZiAoIWlzTW9iaWxlKSB7XG4gICAgICBjb25zdCBsaW5lMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lMScpO1xuICAgICAgY29uc3QgbGluZTIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluZTInKTtcbiAgICAgIGNvbnN0IGxpbmUxVGV4dCA9ICdEb3VnbGFzIEFsdmFyaW5vJztcbiAgICAgIGNvbnN0IGxpbmUyVGV4dCA9ICdFbmdpbmVlciB8fCBEZXZlbG9wZXIgfHwgRXhwbG9yZXInO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IGogPSAwO1xuICAgICAgLy8gUmVzZXQgYW55IHByZS1leGlzdGluZyBjb250ZW50IHRvIGF2b2lkIGRvdWJsZWQgY2hhcmFjdGVycyBvbiBITVIvcmVtb3VudFxuICAgICAgaWYgKGxpbmUxKSBsaW5lMS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgaWYgKGxpbmUyKSBsaW5lMi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgZnVuY3Rpb24gdHlwZUxpbmUxKCkge1xuICAgICAgICBpZiAoIWxpbmUxKSByZXR1cm47XG4gICAgICAgIGlmIChpIDwgbGluZTFUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIGxpbmUxLnRleHRDb250ZW50ID0gKGxpbmUxLnRleHRDb250ZW50IHx8ICcnKSArIGxpbmUxVGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgbW92ZUN1cnNvclRvKGxpbmUxKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgdGltZW91dHMucHVzaCh3aW5kb3cuc2V0VGltZW91dCh0eXBlTGluZTEsIDgwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dHMucHVzaCh3aW5kb3cuc2V0VGltZW91dCh0eXBlTGluZTIsIDQwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0eXBlTGluZTIoKSB7XG4gICAgICAgIGlmICghbGluZTIpIHJldHVybjtcbiAgICAgICAgaWYgKGogPCBsaW5lMlRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgbGluZTIudGV4dENvbnRlbnQgPSAobGluZTIudGV4dENvbnRlbnQgfHwgJycpICsgbGluZTJUZXh0LmNoYXJBdChqKTtcbiAgICAgICAgICBtb3ZlQ3Vyc29yVG8obGluZTIpO1xuICAgICAgICAgIGorKztcbiAgICAgICAgICB0aW1lb3V0cy5wdXNoKHdpbmRvdy5zZXRUaW1lb3V0KHR5cGVMaW5lMiwgODApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGltZW91dHMucHVzaCh3aW5kb3cuc2V0VGltZW91dCh0eXBlTGluZTEsIDM1MCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNIVE1MRWxlbWVudChpbnRybykgJiYgaXNIVE1MRWxlbWVudChjdXJzb3IpKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lMS1jb250YWluZXInKT8ucmVtb3ZlKCk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lMi1jb250YWluZXInKT8ucmVtb3ZlKCk7XG4gICAgICAgIGNvbnN0IG1vYmlsZUxpbmVzID0gWydEb3VnbGFzIEFsdmFyaW5vJywgJ0VuZ2luZWVyIHx8IERldmVsb3BlciB8fCBFeHBsb3JlciddO1xuICAgICAgICBsZXQgY3VycmVudExpbmUgPSAwO1xuICAgICAgICBsZXQgY2hhckluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgbGluZVNwYW5zOiBIVE1MU3BhbkVsZW1lbnRbXSA9IFtdO1xuICAgICAgICBjb25zdCBwcm9tcHRTcGFuczogSFRNTFNwYW5FbGVtZW50W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2JpbGVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxpbmVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBsaW5lRGl2LmNsYXNzTmFtZSA9ICd0ZXJtaW5hbC1saW5lJztcbiAgICAgICAgICBjb25zdCBwcm9tcHRTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgIHByb21wdFNwYW4uY2xhc3NOYW1lID0gJ3Byb21wdCc7XG4gICAgICAgICAgcHJvbXB0U3Bhbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgIHByb21wdFNwYW5zLnB1c2gocHJvbXB0U3Bhbik7XG4gICAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICBzcGFuLmlkID0gYG1vYmlsZS1saW5lLSR7aX1gO1xuICAgICAgICAgIGxpbmVTcGFucy5wdXNoKHNwYW4pO1xuICAgICAgICAgIGxpbmVEaXYuYXBwZW5kQ2hpbGQocHJvbXB0U3Bhbik7XG4gICAgICAgICAgbGluZURpdi5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICBpbnRyby5pbnNlcnRCZWZvcmUobGluZURpdiwgY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0eXBlTW9iaWxlTGluZSgpIHtcbiAgICAgICAgICBpZiAoY3VycmVudExpbmUgPj0gbW9iaWxlTGluZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcHJvbXB0ID0gcHJvbXB0U3BhbnNbY3VycmVudExpbmVdO1xuICAgICAgICAgIGNvbnN0IHNwYW4gPSBsaW5lU3BhbnNbY3VycmVudExpbmVdO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBtb2JpbGVMaW5lc1tjdXJyZW50TGluZV07XG4gICAgICAgICAgZnVuY3Rpb24gdHlwZVByb21wdCgpIHtcbiAgICAgICAgICAgIHByb21wdC50ZXh0Q29udGVudCA9ICc+ICc7XG4gICAgICAgICAgICBtb3ZlQ3Vyc29yVG8ocHJvbXB0KTtcbiAgICAgICAgICAgIHRpbWVvdXRzLnB1c2god2luZG93LnNldFRpbWVvdXQodHlwZVdvcmQsIDE4MCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB0eXBlV29yZCgpIHtcbiAgICAgICAgICAgIGlmIChjaGFySW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gKHNwYW4udGV4dENvbnRlbnQgfHwgJycpICsgdGV4dC5jaGFyQXQoY2hhckluZGV4KTtcbiAgICAgICAgICAgICAgbW92ZUN1cnNvclRvKHNwYW4pO1xuICAgICAgICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgICAgICAgICAgdGltZW91dHMucHVzaCh3aW5kb3cuc2V0VGltZW91dCh0eXBlV29yZCwgODApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMaW5lKys7XG4gICAgICAgICAgICAgIGNoYXJJbmRleCA9IDA7XG4gICAgICAgICAgICAgIHRpbWVvdXRzLnB1c2god2luZG93LnNldFRpbWVvdXQodHlwZU1vYmlsZUxpbmUsIDMwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlUHJvbXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dHMucHVzaCh3aW5kb3cuc2V0VGltZW91dCh0eXBlTW9iaWxlTGluZSwgMzUwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2Nyb2xsIGN1ZVxuICAgIGNvbnN0IGN1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY3JvbGwtY3VlJyk7XG4gICAgY29uc3QgYWJvdXRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Fib3V0Jyk7XG4gICAgbGV0IHNjcm9sbGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gc2Nyb2xsVG9BYm91dCgpIHtcbiAgICAgIGlmICghc2Nyb2xsZWQgJiYgaXNIVE1MRWxlbWVudChhYm91dFNlY3Rpb24pKSB7XG4gICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgYWJvdXRTZWN0aW9uLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjdWU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2Nyb2xsVG9BYm91dCk7XG4gICAgY29uc3Qgb25XaGVlbCA9IChlOiBXaGVlbEV2ZW50KSA9PiB7IGlmIChlLmRlbHRhWSA+IDApIHNjcm9sbFRvQWJvdXQoKTsgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICAvLyBOYXZiYXIgaGFtYnVyZ2VyIHRvZ2dsZVxuICAgIGNvbnN0IGhhbWJ1cmdlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoYW1idXJnZXInKTtcbiAgICBjb25zdCBuYXZMaW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYXYtbGlua3MnKTtcbiAgICBjb25zdCBvbkhhbWJ1cmdlciA9ICgpID0+IHtcbiAgICAgIGhhbWJ1cmdlcj8uY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG4gICAgICBuYXZMaW5rcz8uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpO1xuICAgIH07XG4gICAgaGFtYnVyZ2VyPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uSGFtYnVyZ2VyKTtcbiAgICBuYXZMaW5rcz8ucXVlcnlTZWxlY3RvckFsbCgnYScpLmZvckVhY2gobGluayA9PiB7XG4gICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPD0gNzY4KSB7XG4gICAgICAgICAgbmF2TGlua3MuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICAgIGhhbWJ1cmdlcj8uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gU2tpbGxzIGNhcm91c2VsIGFuZCBmaWx0ZXJzXG4gICAgY29uc3Qgc2tpbGxzQ2Fyb3VzZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2tpbGxzLWNhcm91c2VsJyk7XG4gICAgY29uc3Qgc2tpbGxzQ2F0ZWdvcmllcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdza2lsbHMtY2F0ZWdvcmllcycpO1xuICAgIGNvbnN0IGNhcm91c2VsV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJvdXNlbC1za2lsbC1jYXJkLXdyYXBwZXInKSBhcyBIVE1MRWxlbWVudCB8IG51bGw7XG4gICAgY29uc3QgbGVmdEFycm93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nhcm91c2VsLWxlZnQnKSBhcyBIVE1MQnV0dG9uRWxlbWVudCB8IG51bGw7XG4gICAgY29uc3QgcmlnaHRBcnJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXJvdXNlbC1yaWdodCcpIGFzIEhUTUxCdXR0b25FbGVtZW50IHwgbnVsbDtcbiAgICBjb25zdCBmaWx0ZXJCYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2tpbGxzLWZpbHRlcicpO1xuICAgIGNvbnN0IGZpbHRlckJ1dHRvbnMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEJ1dHRvbkVsZW1lbnQ+KCcuZmlsdGVyLWJ0bicpKTtcbiAgICBsZXQgYWxsU2tpbGxDYXJkcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oJy5za2lsbC1jYXJkJykpLm1hcChjYXJkID0+IGNhcmQuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50KTtcbiAgICBsZXQgY2Fyb3VzZWxJbmRleCA9IDA7XG4gICAgZnVuY3Rpb24gc2hvd0Nhcm91c2VsU2tpbGwoaWR4OiBudW1iZXIpIHtcbiAgICAgIGlmICghY2Fyb3VzZWxXcmFwcGVyKSByZXR1cm47XG4gICAgICBjYXJvdXNlbFdyYXBwZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICBjb25zdCBjYXJkID0gYWxsU2tpbGxDYXJkc1tpZHhdO1xuICAgICAgaWYgKGNhcmQpIHtcbiAgICAgICAgY2Fyb3VzZWxXcmFwcGVyLmFwcGVuZENoaWxkKGNhcmQpO1xuICAgICAgICBjb25zdCBwcm9ncmVzc0JhciA9IGNhcmQucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oJy5wcm9ncmVzcy1iYXInKTtcbiAgICAgICAgaWYgKHByb2dyZXNzQmFyKSB7XG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSAoY2FyZCBhcyBIVE1MRWxlbWVudCkuZGF0YXNldC5sZXZlbCB8fCAnMCc7XG4gICAgICAgICAgcHJvZ3Jlc3NCYXIuc3R5bGUuc2V0UHJvcGVydHkoJy0tcHJvZ3Jlc3Mtd2lkdGgnLCBgJHtwcm9ncmVzc30lYCk7XG4gICAgICAgICAgY2FyZC5jbGFzc0xpc3QuYWRkKCdhbmltYXRlJyk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3N9JWA7IH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxlZnRBcnJvdz8udG9nZ2xlQXR0cmlidXRlKCdkaXNhYmxlZCcsIGlkeCA9PT0gMCk7XG4gICAgICByaWdodEFycm93Py50b2dnbGVBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgaWR4ID09PSBhbGxTa2lsbENhcmRzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY3RpdmF0ZUNhcm91c2VsKCkge1xuICAgICAgYWxsU2tpbGxDYXJkcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oJy5za2lsbC1jYXJkJykpLm1hcChjYXJkID0+IGNhcmQuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgIGlmIChza2lsbHNDYXJvdXNlbCkgKHNraWxsc0Nhcm91c2VsIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICBza2lsbHNDYXRlZ29yaWVzPy5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XG4gICAgICBjYXJvdXNlbEluZGV4ID0gMDtcbiAgICAgIHNob3dDYXJvdXNlbFNraWxsKGNhcm91c2VsSW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWFjdGl2YXRlQ2Fyb3VzZWwoKSB7XG4gICAgICBpZiAoc2tpbGxzQ2Fyb3VzZWwpIChza2lsbHNDYXJvdXNlbCBhcyBIVE1MRWxlbWVudCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHNraWxsc0NhdGVnb3JpZXM/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcbiAgICB9XG4gICAgbGVmdEFycm93Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGlmIChjYXJvdXNlbEluZGV4ID4gMCkgeyBjYXJvdXNlbEluZGV4LS07IHNob3dDYXJvdXNlbFNraWxsKGNhcm91c2VsSW5kZXgpOyB9XG4gICAgfSk7XG4gICAgcmlnaHRBcnJvdz8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBpZiAoY2Fyb3VzZWxJbmRleCA8IGFsbFNraWxsQ2FyZHMubGVuZ3RoIC0gMSkgeyBjYXJvdXNlbEluZGV4Kys7IHNob3dDYXJvdXNlbFNraWxsKGNhcm91c2VsSW5kZXgpOyB9XG4gICAgfSk7XG4gICAgbGV0IHNraWxsc1N0YXJ0WCA9IDA7XG4gICAgbGV0IHNraWxsc1N3aXBpbmcgPSBmYWxzZTtcbiAgICBjYXJvdXNlbFdyYXBwZXI/LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoZTogVG91Y2hFdmVudCkgPT4geyBza2lsbHNTdGFydFggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDsgc2tpbGxzU3dpcGluZyA9IHRydWU7IH0pO1xuICAgIGNhcm91c2VsV3JhcHBlcj8uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgIGlmICghc2tpbGxzU3dpcGluZykgcmV0dXJuO1xuICAgICAgY29uc3QgZGlmZlggPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHNraWxsc1N0YXJ0WDtcbiAgICAgIGlmIChNYXRoLmFicyhkaWZmWCkgPiA1MCkge1xuICAgICAgICBpZiAoZGlmZlggPCAwICYmIGNhcm91c2VsSW5kZXggPCBhbGxTa2lsbENhcmRzLmxlbmd0aCAtIDEpIHsgY2Fyb3VzZWxJbmRleCsrOyBzaG93Q2Fyb3VzZWxTa2lsbChjYXJvdXNlbEluZGV4KTsgfVxuICAgICAgICBlbHNlIGlmIChkaWZmWCA+IDAgJiYgY2Fyb3VzZWxJbmRleCA+IDApIHsgY2Fyb3VzZWxJbmRleC0tOyBzaG93Q2Fyb3VzZWxTa2lsbChjYXJvdXNlbEluZGV4KTsgfVxuICAgICAgICBza2lsbHNTd2lwaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2Fyb3VzZWxXcmFwcGVyPy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHsgc2tpbGxzU3dpcGluZyA9IGZhbHNlOyB9KTtcbiAgICBmaWx0ZXJCYXI/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGU6IEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmICghdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZmlsdGVyLWJ0bicpKSByZXR1cm47XG4gICAgICBmaWx0ZXJCdXR0b25zLmZvckVhY2goYnRuID0+IGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKSk7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICBjb25zdCBmaWx0ZXIgPSB0YXJnZXQuZGF0YXNldC5maWx0ZXI7XG4gICAgICBpZiAoZmlsdGVyID09PSAnYWxsJykge1xuICAgICAgICBhY3RpdmF0ZUNhcm91c2VsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2Fyb3VzZWwoKTtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oJy5za2lsbC1jYXRlZ29yeScpLmZvckVhY2goY2F0ID0+IHtcbiAgICAgICAgICBjYXQuc3R5bGUuZGlzcGxheSA9IGNhdC5kYXRhc2V0LmNhdGVnb3J5ID09PSBmaWx0ZXIgPyAnJyA6ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEVsZW1lbnQ+KCcuc2tpbGwtY2F0ZWdvcnknKS5mb3JFYWNoKGNhdCA9PiB7XG4gICAgICAgICAgaWYgKGNhdC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGNhdC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxFbGVtZW50PignLnNraWxsLWNhcmQnKS5mb3JFYWNoKGNhcmQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzc0JhciA9IGNhcmQucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oJy5wcm9ncmVzcy1iYXInKTtcbiAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBjYXJkLmRhdGFzZXQubGV2ZWwgfHwgJzAnO1xuICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9ICcwJSc7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuc3R5bGUuc2V0UHJvcGVydHkoJy0tcHJvZ3Jlc3Mtd2lkdGgnLCBgJHtwcm9ncmVzc30lYCk7XG4gICAgICAgICAgICAgICAgY2FyZC5jbGFzc0xpc3QucmVtb3ZlKCdhbmltYXRlJyk7XG4gICAgICAgICAgICAgICAgdm9pZCBwcm9ncmVzc0Jhci5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICBjYXJkLmNsYXNzTGlzdC5hZGQoJ2FuaW1hdGUnKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgcHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSBgJHtwcm9ncmVzc30lYDsgfSwgMTAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBwcm9ncmFtbWluZ0J0biA9IGZpbHRlckJ1dHRvbnMuZmluZChidG4gPT4gYnRuLmRhdGFzZXQuZmlsdGVyID09PSAncHJvZ3JhbW1pbmcnKTtcbiAgICBpZiAocHJvZ3JhbW1pbmdCdG4pIHNldFRpbWVvdXQoKCkgPT4gcHJvZ3JhbW1pbmdCdG4uY2xpY2soKSwgMCk7XG5cbiAgICAvLyBIaWdobGlnaHQgcHJvamVjdHMgY2Fyb3VzZWxcbiAgICBjb25zdCB0cmFjayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJvdXNlbC10cmFjaycpIGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcbiAgICBjb25zdCBub2RlcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oJy5oaWdobGlnaHQtbm9kZScpKTtcbiAgICBjb25zdCBwcmV2QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nhcm91c2VsLXByZXYnKTtcbiAgICBjb25zdCBuZXh0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nhcm91c2VsLW5leHQnKTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgc2xpZGVXaWR0aCA9IDA7XG4gICAgbGV0IGdhcFB4ID0gMDtcbiAgICBmdW5jdGlvbiBtZWFzdXJlU2xpZGVzKCkge1xuICAgICAgaWYgKCF0cmFjayB8fCBub2Rlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHNsaWRlV2lkdGggPSBub2Rlc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRyYWNrKTtcbiAgICAgIC8vIGdhcCBtYXkgYmUgbGlrZSBcIjE2cHhcIlxuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VGbG9hdChzdHlsZXMuZ2FwIHx8ICcwJyk7XG4gICAgICBnYXBQeCA9IE51bWJlci5pc05hTihwYXJzZWQpID8gMCA6IHBhcnNlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlTbGlkZUNsYXNzZXMoKSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKChub2RlLCBpZHgpID0+IHtcbiAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBpZHggPT09IGN1cnJlbnRJbmRleDtcbiAgICAgICAgY29uc3QgaXNOZWFyID0gaWR4ID09PSBjdXJyZW50SW5kZXggLSAxIHx8IGlkeCA9PT0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgY29uc3QgaXNGYXIgPSBNYXRoLmFicyhpZHggLSBjdXJyZW50SW5kZXgpID4gMTtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QudG9nZ2xlKCdzbGlkZS0tYWN0aXZlJywgaXNBY3RpdmUpO1xuICAgICAgICBub2RlLmNsYXNzTGlzdC50b2dnbGUoJ3NsaWRlLS1uZWFyJywgaXNOZWFyKTtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QudG9nZ2xlKCdzbGlkZS0tZmFyJywgaXNGYXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhcm91c2VsKCkge1xuICAgICAgaWYgKCF0cmFjaykgcmV0dXJuO1xuICAgICAgY29uc3Qgb2Zmc2V0UHggPSAtKHNsaWRlV2lkdGggKyBnYXBQeCkgKiBjdXJyZW50SW5kZXg7XG4gICAgICB0cmFjay5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke29mZnNldFB4fXB4KWA7XG4gICAgICBhcHBseVNsaWRlQ2xhc3NlcygpO1xuICAgIH1cbiAgICBwcmV2QnRuPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHsgaWYgKGN1cnJlbnRJbmRleCA+IDApIHsgY3VycmVudEluZGV4LS07IHVwZGF0ZUNhcm91c2VsKCk7IH0gfSk7XG4gICAgbmV4dEJ0bj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7IGlmIChjdXJyZW50SW5kZXggPCBub2Rlcy5sZW5ndGggLSAxKSB7IGN1cnJlbnRJbmRleCsrOyB1cGRhdGVDYXJvdXNlbCgpOyB9IH0pO1xuICAgIGxldCBwcm9qZWN0U3RhcnRYID0gMDtcbiAgICBsZXQgcHJvamVjdFN3aXBpbmcgPSBmYWxzZTtcbiAgICB0cmFjaz8uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChlOiBUb3VjaEV2ZW50KSA9PiB7IHByb2plY3RTdGFydFggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDsgcHJvamVjdFN3aXBpbmcgPSB0cnVlOyB9KTtcbiAgICB0cmFjaz8uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgIGlmICghcHJvamVjdFN3aXBpbmcpIHJldHVybjtcbiAgICAgIGNvbnN0IGRpZmZYID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBwcm9qZWN0U3RhcnRYO1xuICAgICAgaWYgKE1hdGguYWJzKGRpZmZYKSA+IDUwKSB7XG4gICAgICAgIGlmIChkaWZmWCA8IDAgJiYgY3VycmVudEluZGV4IDwgbm9kZXMubGVuZ3RoIC0gMSkgY3VycmVudEluZGV4Kys7XG4gICAgICAgIGVsc2UgaWYgKGRpZmZYID4gMCAmJiBjdXJyZW50SW5kZXggPiAwKSBjdXJyZW50SW5kZXgtLTtcbiAgICAgICAgdXBkYXRlQ2Fyb3VzZWwoKTtcbiAgICAgICAgcHJvamVjdFN3aXBpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cmFjaz8uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoKSA9PiB7IHByb2plY3RTd2lwaW5nID0gZmFsc2U7IH0pO1xuICAgIGFjdGl2YXRlQ2Fyb3VzZWwoKTtcbiAgICBtZWFzdXJlU2xpZGVzKCk7XG4gICAgdXBkYXRlQ2Fyb3VzZWwoKTtcbiAgICBjb25zdCBvblJlc2l6ZUNhcm91c2VsID0gKCkgPT4geyBtZWFzdXJlU2xpZGVzKCk7IHVwZGF0ZUNhcm91c2VsKCk7IH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplQ2Fyb3VzZWwpO1xuXG4gICAgLy8gTmF2YmFyIGhpZGUvc2hvdyBvbiBzY3JvbGxcbiAgICBsZXQgbGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgY29uc3QgbmF2YmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5hdmJhcicpO1xuICAgIGNvbnN0IG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIGlmIChzY3JvbGxUb3AgPiBsYXN0U2Nyb2xsVG9wKSBuYXZiYXI/LmNsYXNzTGlzdC5hZGQoJ25hdmJhci1oaWRkZW4nKTtcbiAgICAgIGVsc2UgbmF2YmFyPy5jbGFzc0xpc3QucmVtb3ZlKCduYXZiYXItaGlkZGVuJyk7XG4gICAgICBsYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wIDw9IDAgPyAwIDogc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICAvLyBNYXRyaXggYmFja2dyb3VuZCBjYW52YXMgdW5kZXIgI2xhbmRpbmdcbiAgICBjb25zdCBsYW5kaW5nRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFuZGluZycpIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgICBpZiAobGFuZGluZ0VsKSB7XG4gICAgICBjb25zdCBtYXRyaXhDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNvbnN0IGxhbmRpbmcgPSBsYW5kaW5nRWw7IC8vIG5hcnJvdyBmb3IgaW5uZXIgY2xvc3VyZXNcbiAgICAgIGxhbmRpbmcuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgbGFuZGluZy5hcHBlbmRDaGlsZChtYXRyaXhDYW52YXMpO1xuICAgICAgY29uc3QgY3R4ID0gbWF0cml4Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICAvLyBDbGVhbnVwIGZhbGxiYWNrXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgICAgICBoYW1idXJnZXI/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25IYW1idXJnZXIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gY3R4O1xuICAgICAgLy8gU3R5bGUgYXNzaWdubWVudHNcbiAgICAgIG1hdHJpeENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBtYXRyaXhDYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgbWF0cml4Q2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICBtYXRyaXhDYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBtYXRyaXhDYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgbWF0cml4Q2FudmFzLnN0eWxlLnpJbmRleCA9ICcwJztcbiAgICAgIG1hdHJpeENhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgbWF0cml4Q2FudmFzLnN0eWxlLm9wYWNpdHkgPSAnMC4wOCc7XG4gICAgICBtYXRyaXhDYW52YXMuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDAuM3MgZWFzZSc7XG5cbiAgICAgIGNvbnN0IGxldHRlcnMgPSAnMDHjgqLjgqvjgrXjgr/jg4rjg4/jg57jg6Tjg6kwMTIzNDU2Nzg5JztcbiAgICAgIGNvbnN0IGZvbnRTaXplID0gMTQ7XG4gICAgICBsZXQgZHJvcHM6IG51bWJlcltdID0gW107XG4gICAgICBsZXQgbGFzdFdpZHRoID0gMDtcbiAgICAgIGxldCBsYXN0SGVpZ2h0ID0gMDtcbiAgICAgIGZ1bmN0aW9uIHJlc2l6ZU1hdHJpeENhbnZhcyhmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFuZGluZy5jbGllbnRXaWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICBpZiAoIWZvcmNlICYmIHdpZHRoID09PSBsYXN0V2lkdGggJiYgaGVpZ2h0ID09PSBsYXN0SGVpZ2h0KSByZXR1cm47XG4gICAgICAgIGNvbnN0IG9sZENvbHVtbnMgPSBkcm9wcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0NvbHVtbnMgPSBNYXRoLmZsb29yKHdpZHRoIC8gZm9udFNpemUpO1xuICAgICAgICBpZiAobWF0cml4Q2FudmFzLndpZHRoICE9PSB3aWR0aCkgbWF0cml4Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGlmIChtYXRyaXhDYW52YXMuaGVpZ2h0ICE9PSBoZWlnaHQpIG1hdHJpeENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmIChuZXdDb2x1bW5zICE9PSBvbGRDb2x1bW5zKSB7XG4gICAgICAgICAgY29uc3Qgb2xkRHJvcHMgPSBbLi4uZHJvcHNdO1xuICAgICAgICAgIGRyb3BzLmxlbmd0aCA9IG5ld0NvbHVtbnM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIGRyb3BzW2ldID0gb2xkRHJvcHNbaV0gfHwgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5mb250ID0gXCIxNHB4ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZVwiO1xuICAgICAgICBsYXN0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgbGFzdEhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRyYXdNYXRyaXgoKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4wNSknO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIG1hdHJpeENhbnZhcy53aWR0aCwgbWF0cml4Q2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwZjAnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IGxldHRlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxldHRlcnMubGVuZ3RoKSk7XG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCBpICogZm9udFNpemUsIGRyb3BzW2ldICogZm9udFNpemUpO1xuICAgICAgICAgIGlmIChkcm9wc1tpXSAqIGZvbnRTaXplID4gbWF0cml4Q2FudmFzLmhlaWdodCB8fCBNYXRoLnJhbmRvbSgpID4gMC45NzUpIHsgZHJvcHNbaV0gPSAwOyB9XG4gICAgICAgICAgZHJvcHNbaV0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzaXplTWF0cml4Q2FudmFzKHRydWUpO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZHJhd01hdHJpeCwgNTApO1xuICAgICAgbGV0IHJlc2l6ZVRpbWVvdXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICByZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gcmVzaXplTWF0cml4Q2FudmFzKCksIDIwMCkgYXMgdW5rbm93biBhcyBudW1iZXI7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgIC8vIENsZWFudXAgY2FudmFzIGxpc3RlbmVycy9pbnRlcnZhbFxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRpbWVvdXRzLmZvckVhY2goaWQgPT4gd2luZG93LmNsZWFyVGltZW91dChpZCkpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZUNhcm91c2VsKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIGhhbWJ1cmdlcj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkhhbWJ1cmdlcik7XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENsZWFudXAgZm9yIG5vbi1jYW52YXMgY2FzZVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aW1lb3V0cy5mb3JFYWNoKGlkID0+IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZUNhcm91c2VsKTtcbiAgICAgIGhhbWJ1cmdlcj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkhhbWJ1cmdlcik7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJBT1MiLCJpc0hUTUxFbGVtZW50IiwiZWwiLCJIVE1MRWxlbWVudCIsIkluaXRDbGllbnQiLCJpbml0IiwiZHVyYXRpb24iLCJlYXNpbmciLCJvZmZzZXQiLCJvbmNlIiwiaW50cm8iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjdXJzb3IiLCJnZXRFbGVtZW50QnlJZCIsImlzTW9iaWxlIiwid2luZG93IiwiaW5uZXJXaWR0aCIsIm1vdmVDdXJzb3JUbyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbnRyb1JlY3QiLCJzdHlsZSIsInRvcCIsImxlZnQiLCJ3aWR0aCIsInRpbWVvdXRzIiwibGluZTEiLCJsaW5lMiIsImxpbmUxVGV4dCIsImxpbmUyVGV4dCIsImkiLCJqIiwidGV4dENvbnRlbnQiLCJ0eXBlTGluZTEiLCJsZW5ndGgiLCJjaGFyQXQiLCJwdXNoIiwic2V0VGltZW91dCIsInR5cGVMaW5lMiIsInJlbW92ZSIsIm1vYmlsZUxpbmVzIiwiY3VycmVudExpbmUiLCJjaGFySW5kZXgiLCJsaW5lU3BhbnMiLCJwcm9tcHRTcGFucyIsImxpbmVEaXYiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicHJvbXB0U3BhbiIsInNwYW4iLCJpZCIsImFwcGVuZENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwidHlwZU1vYmlsZUxpbmUiLCJwcm9tcHQiLCJ0ZXh0IiwidHlwZVByb21wdCIsInR5cGVXb3JkIiwiY3VlIiwiYWJvdXRTZWN0aW9uIiwic2Nyb2xsZWQiLCJzY3JvbGxUb0Fib3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbldoZWVsIiwiZSIsImRlbHRhWSIsInBhc3NpdmUiLCJoYW1idXJnZXIiLCJuYXZMaW5rcyIsIm9uSGFtYnVyZ2VyIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJsaW5rIiwic2tpbGxzQ2Fyb3VzZWwiLCJza2lsbHNDYXRlZ29yaWVzIiwiY2Fyb3VzZWxXcmFwcGVyIiwibGVmdEFycm93IiwicmlnaHRBcnJvdyIsImZpbHRlckJhciIsImZpbHRlckJ1dHRvbnMiLCJBcnJheSIsImZyb20iLCJhbGxTa2lsbENhcmRzIiwibWFwIiwiY2FyZCIsImNsb25lTm9kZSIsImNhcm91c2VsSW5kZXgiLCJzaG93Q2Fyb3VzZWxTa2lsbCIsImlkeCIsImlubmVySFRNTCIsInByb2dyZXNzQmFyIiwicHJvZ3Jlc3MiLCJkYXRhc2V0IiwibGV2ZWwiLCJzZXRQcm9wZXJ0eSIsImFkZCIsInRvZ2dsZUF0dHJpYnV0ZSIsImFjdGl2YXRlQ2Fyb3VzZWwiLCJkaXNwbGF5IiwiZGVhY3RpdmF0ZUNhcm91c2VsIiwic2tpbGxzU3RhcnRYIiwic2tpbGxzU3dpcGluZyIsInRvdWNoZXMiLCJjbGllbnRYIiwiZGlmZlgiLCJNYXRoIiwiYWJzIiwidGFyZ2V0IiwiY29udGFpbnMiLCJidG4iLCJmaWx0ZXIiLCJjYXQiLCJjYXRlZ29yeSIsIm9mZnNldFdpZHRoIiwicHJvZ3JhbW1pbmdCdG4iLCJmaW5kIiwiY2xpY2siLCJ0cmFjayIsIm5vZGVzIiwicHJldkJ0biIsIm5leHRCdG4iLCJjdXJyZW50SW5kZXgiLCJzbGlkZVdpZHRoIiwiZ2FwUHgiLCJtZWFzdXJlU2xpZGVzIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBhcnNlZCIsInBhcnNlRmxvYXQiLCJnYXAiLCJOdW1iZXIiLCJpc05hTiIsImFwcGx5U2xpZGVDbGFzc2VzIiwibm9kZSIsImlzQWN0aXZlIiwiaXNOZWFyIiwiaXNGYXIiLCJ1cGRhdGVDYXJvdXNlbCIsIm9mZnNldFB4IiwidHJhbnNmb3JtIiwicHJvamVjdFN0YXJ0WCIsInByb2plY3RTd2lwaW5nIiwib25SZXNpemVDYXJvdXNlbCIsImxhc3RTY3JvbGxUb3AiLCJuYXZiYXIiLCJvblNjcm9sbCIsInNjcm9sbFRvcCIsInNjcm9sbFkiLCJkb2N1bWVudEVsZW1lbnQiLCJsYW5kaW5nRWwiLCJtYXRyaXhDYW52YXMiLCJsYW5kaW5nIiwicG9zaXRpb24iLCJjdHgiLCJnZXRDb250ZXh0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbnRleHQiLCJoZWlnaHQiLCJ6SW5kZXgiLCJwb2ludGVyRXZlbnRzIiwib3BhY2l0eSIsInRyYW5zaXRpb24iLCJsZXR0ZXJzIiwiZm9udFNpemUiLCJkcm9wcyIsImxhc3RXaWR0aCIsImxhc3RIZWlnaHQiLCJyZXNpemVNYXRyaXhDYW52YXMiLCJmb3JjZSIsImNsaWVudFdpZHRoIiwiaW5uZXJIZWlnaHQiLCJvbGRDb2x1bW5zIiwibmV3Q29sdW1ucyIsImZsb29yIiwib2xkRHJvcHMiLCJmb250IiwiZHJhd01hdHJpeCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicmFuZG9tIiwiZmlsbFRleHQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwicmVzaXplVGltZW91dCIsIm9uUmVzaXplIiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJJbnRlcnZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/InitClient.tsx\n"));

/***/ })

});